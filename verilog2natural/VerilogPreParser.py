# Generated from VerilogPreParser.g4 by ANTLR 4.13.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,245,321,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,1,0,5,0,96,8,0,10,0,12,0,99,9,0,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,118,8,1,1,2,1,2,
        1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,1,5,1,5,1,6,1,6,1,6,
        1,6,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,9,1,9,1,9,1,10,1,10,1,10,1,
        11,1,11,1,12,1,12,5,12,157,8,12,10,12,12,12,160,9,12,1,13,1,13,1,
        14,1,14,1,14,1,14,1,14,5,14,169,8,14,10,14,12,14,172,9,14,1,14,3,
        14,175,8,14,1,14,1,14,1,15,1,15,1,15,1,15,1,15,5,15,184,8,15,10,
        15,12,15,187,9,15,1,15,3,15,190,8,15,1,15,1,15,1,16,1,16,1,16,1,
        16,1,16,1,16,1,17,1,17,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,
        19,1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,
        25,1,25,1,25,1,25,1,25,5,25,228,8,25,10,25,12,25,231,9,25,1,26,1,
        26,1,27,1,27,1,28,1,28,1,28,1,29,1,29,1,30,1,30,1,30,1,30,1,30,1,
        30,5,30,248,8,30,10,30,12,30,251,9,30,3,30,253,8,30,1,31,1,31,1,
        31,3,31,258,8,31,1,31,1,31,1,32,1,32,1,33,1,33,1,34,1,34,1,34,1,
        34,5,34,270,8,34,10,34,12,34,273,9,34,1,34,1,34,1,34,1,34,1,34,3,
        34,280,8,34,1,35,1,35,1,35,1,36,1,36,1,37,1,37,1,38,1,38,1,38,1,
        38,1,38,1,39,1,39,1,39,1,40,1,40,1,40,1,41,1,41,1,41,1,42,1,42,1,
        42,1,42,1,42,1,42,1,43,1,43,1,43,1,43,1,44,1,44,1,45,1,45,1,45,1,
        45,1,46,1,46,1,46,0,0,47,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,
        30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,
        74,76,78,80,82,84,86,88,90,92,0,0,309,0,97,1,0,0,0,2,117,1,0,0,0,
        4,119,1,0,0,0,6,125,1,0,0,0,8,128,1,0,0,0,10,132,1,0,0,0,12,134,
        1,0,0,0,14,138,1,0,0,0,16,143,1,0,0,0,18,146,1,0,0,0,20,149,1,0,
        0,0,22,152,1,0,0,0,24,158,1,0,0,0,26,161,1,0,0,0,28,163,1,0,0,0,
        30,178,1,0,0,0,32,193,1,0,0,0,34,199,1,0,0,0,36,201,1,0,0,0,38,209,
        1,0,0,0,40,211,1,0,0,0,42,213,1,0,0,0,44,215,1,0,0,0,46,217,1,0,
        0,0,48,219,1,0,0,0,50,229,1,0,0,0,52,232,1,0,0,0,54,234,1,0,0,0,
        56,236,1,0,0,0,58,239,1,0,0,0,60,241,1,0,0,0,62,257,1,0,0,0,64,261,
        1,0,0,0,66,263,1,0,0,0,68,279,1,0,0,0,70,281,1,0,0,0,72,284,1,0,
        0,0,74,286,1,0,0,0,76,288,1,0,0,0,78,293,1,0,0,0,80,296,1,0,0,0,
        82,299,1,0,0,0,84,302,1,0,0,0,86,308,1,0,0,0,88,312,1,0,0,0,90,314,
        1,0,0,0,92,318,1,0,0,0,94,96,3,2,1,0,95,94,1,0,0,0,96,99,1,0,0,0,
        97,95,1,0,0,0,97,98,1,0,0,0,98,1,1,0,0,0,99,97,1,0,0,0,100,118,3,
        4,2,0,101,118,3,6,3,0,102,118,3,8,4,0,103,118,3,16,8,0,104,118,3,
        18,9,0,105,118,3,28,14,0,106,118,3,30,15,0,107,118,3,32,16,0,108,
        118,3,36,18,0,109,118,3,56,28,0,110,118,3,60,30,0,111,118,3,70,35,
        0,112,118,3,76,38,0,113,118,3,78,39,0,114,118,3,84,42,0,115,118,
        3,86,43,0,116,118,3,90,45,0,117,100,1,0,0,0,117,101,1,0,0,0,117,
        102,1,0,0,0,117,103,1,0,0,0,117,104,1,0,0,0,117,105,1,0,0,0,117,
        106,1,0,0,0,117,107,1,0,0,0,117,108,1,0,0,0,117,109,1,0,0,0,117,
        110,1,0,0,0,117,111,1,0,0,0,117,112,1,0,0,0,117,113,1,0,0,0,117,
        114,1,0,0,0,117,115,1,0,0,0,117,116,1,0,0,0,118,3,1,0,0,0,119,120,
        5,158,0,0,120,121,5,212,0,0,121,122,5,149,0,0,122,123,3,92,46,0,
        123,124,5,149,0,0,124,5,1,0,0,0,125,126,5,158,0,0,126,127,5,213,
        0,0,127,7,1,0,0,0,128,129,5,158,0,0,129,130,5,214,0,0,130,131,3,
        10,5,0,131,9,1,0,0,0,132,133,5,233,0,0,133,11,1,0,0,0,134,135,5,
        158,0,0,135,136,5,216,0,0,136,137,3,24,12,0,137,13,1,0,0,0,138,139,
        5,158,0,0,139,140,5,217,0,0,140,141,3,44,22,0,141,142,3,24,12,0,
        142,15,1,0,0,0,143,144,5,158,0,0,144,145,5,218,0,0,145,17,1,0,0,
        0,146,147,5,158,0,0,147,148,5,219,0,0,148,19,1,0,0,0,149,150,5,158,
        0,0,150,151,5,220,0,0,151,21,1,0,0,0,152,153,5,235,0,0,153,23,1,
        0,0,0,154,157,3,72,36,0,155,157,3,2,1,0,156,154,1,0,0,0,156,155,
        1,0,0,0,157,160,1,0,0,0,158,156,1,0,0,0,158,159,1,0,0,0,159,25,1,
        0,0,0,160,158,1,0,0,0,161,162,5,198,0,0,162,27,1,0,0,0,163,164,5,
        158,0,0,164,165,5,221,0,0,165,166,3,44,22,0,166,170,3,24,12,0,167,
        169,3,14,7,0,168,167,1,0,0,0,169,172,1,0,0,0,170,168,1,0,0,0,170,
        171,1,0,0,0,171,174,1,0,0,0,172,170,1,0,0,0,173,175,3,12,6,0,174,
        173,1,0,0,0,174,175,1,0,0,0,175,176,1,0,0,0,176,177,3,20,10,0,177,
        29,1,0,0,0,178,179,5,158,0,0,179,180,5,222,0,0,180,181,3,44,22,0,
        181,185,3,24,12,0,182,184,3,14,7,0,183,182,1,0,0,0,184,187,1,0,0,
        0,185,183,1,0,0,0,185,186,1,0,0,0,186,189,1,0,0,0,187,185,1,0,0,
        0,188,190,3,12,6,0,189,188,1,0,0,0,189,190,1,0,0,0,190,191,1,0,0,
        0,191,192,3,20,10,0,192,31,1,0,0,0,193,194,5,158,0,0,194,195,5,223,
        0,0,195,196,5,149,0,0,196,197,3,22,11,0,197,198,5,149,0,0,198,33,
        1,0,0,0,199,200,5,201,0,0,200,35,1,0,0,0,201,202,5,158,0,0,202,203,
        5,224,0,0,203,204,3,58,29,0,204,205,5,149,0,0,205,206,3,22,11,0,
        206,207,5,149,0,0,207,208,3,34,17,0,208,37,1,0,0,0,209,210,5,236,
        0,0,210,39,1,0,0,0,211,212,5,237,0,0,212,41,1,0,0,0,213,214,5,238,
        0,0,214,43,1,0,0,0,215,216,5,245,0,0,216,45,1,0,0,0,217,218,5,234,
        0,0,218,47,1,0,0,0,219,220,5,239,0,0,220,49,1,0,0,0,221,228,3,52,
        26,0,222,228,3,38,19,0,223,228,3,40,20,0,224,228,3,42,21,0,225,228,
        3,48,24,0,226,228,3,74,37,0,227,221,1,0,0,0,227,222,1,0,0,0,227,
        223,1,0,0,0,227,224,1,0,0,0,227,225,1,0,0,0,227,226,1,0,0,0,228,
        231,1,0,0,0,229,227,1,0,0,0,229,230,1,0,0,0,230,51,1,0,0,0,231,229,
        1,0,0,0,232,233,5,240,0,0,233,53,1,0,0,0,234,235,5,231,0,0,235,55,
        1,0,0,0,236,237,5,158,0,0,237,238,5,225,0,0,238,57,1,0,0,0,239,240,
        5,201,0,0,240,59,1,0,0,0,241,242,5,158,0,0,242,243,5,226,0,0,243,
        252,3,66,33,0,244,249,3,62,31,0,245,246,5,147,0,0,246,248,3,62,31,
        0,247,245,1,0,0,0,248,251,1,0,0,0,249,247,1,0,0,0,249,250,1,0,0,
        0,250,253,1,0,0,0,251,249,1,0,0,0,252,244,1,0,0,0,252,253,1,0,0,
        0,253,61,1,0,0,0,254,255,3,64,32,0,255,256,5,154,0,0,256,258,1,0,
        0,0,257,254,1,0,0,0,257,258,1,0,0,0,258,259,1,0,0,0,259,260,3,68,
        34,0,260,63,1,0,0,0,261,262,5,198,0,0,262,65,1,0,0,0,263,264,5,198,
        0,0,264,67,1,0,0,0,265,266,5,166,0,0,266,271,3,62,31,0,267,268,5,
        147,0,0,268,270,3,62,31,0,269,267,1,0,0,0,270,273,1,0,0,0,271,269,
        1,0,0,0,271,272,1,0,0,0,272,274,1,0,0,0,273,271,1,0,0,0,274,275,
        5,180,0,0,275,280,1,0,0,0,276,280,3,58,29,0,277,280,3,74,37,0,278,
        280,3,26,13,0,279,265,1,0,0,0,279,276,1,0,0,0,279,277,1,0,0,0,279,
        278,1,0,0,0,280,69,1,0,0,0,281,282,5,158,0,0,282,283,5,227,0,0,283,
        71,1,0,0,0,284,285,5,241,0,0,285,73,1,0,0,0,286,287,5,199,0,0,287,
        75,1,0,0,0,288,289,5,158,0,0,289,290,5,215,0,0,290,291,3,46,23,0,
        291,292,3,50,25,0,292,77,1,0,0,0,293,294,5,158,0,0,294,295,3,54,
        27,0,295,79,1,0,0,0,296,297,5,243,0,0,297,298,5,242,0,0,298,81,1,
        0,0,0,299,300,5,243,0,0,300,301,5,242,0,0,301,83,1,0,0,0,302,303,
        5,158,0,0,303,304,5,228,0,0,304,305,3,82,41,0,305,306,5,182,0,0,
        306,307,3,80,40,0,307,85,1,0,0,0,308,309,5,158,0,0,309,310,5,229,
        0,0,310,311,3,88,44,0,311,87,1,0,0,0,312,313,5,244,0,0,313,89,1,
        0,0,0,314,315,5,158,0,0,315,316,5,230,0,0,316,317,3,44,22,0,317,
        91,1,0,0,0,318,319,5,232,0,0,319,93,1,0,0,0,15,97,117,156,158,170,
        174,185,189,227,229,249,252,257,271,279
    ]

class VerilogPreParser ( Parser ):

    grammarFileName = "VerilogPreParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'always'", "'and'", "'assign'", "'automatic'", 
                     "'begin'", "'buf'", "'bufif1'", "'bufif0'", "'case'", 
                     "'casex'", "'casez'", "'cell'", "'cmos'", "'config'", 
                     "'deassign'", "'default'", "'defparam'", "'design'", 
                     "'disable'", "'$fullskew'", "'$hold'", "'$nochange'", 
                     "'$period'", "'$recovery'", "'$recrem'", "'$removal'", 
                     "'$setup'", "'$setuphold'", "'$skew'", "'$timeskew'", 
                     "'$width'", "'edge'", "'else'", "'end'", "'endcase'", 
                     "'endconfig'", "'endfunction'", "'endgenerate'", "'endmodule'", 
                     "'endprimitive'", "'endspecify'", "'endtable'", "'endtask'", 
                     "'event'", "'for'", "'force'", "'forever'", "'fork'", 
                     "'function'", "'generate'", "'genvar'", "'highz1'", 
                     "'highz0'", "'if'", "'ifnone'", "'include'", "'initial'", 
                     "'inout'", "'input'", "'instance'", "'integer'", "'join'", 
                     "'large'", "'liblist'", "'library'", "'localparam'", 
                     "'macromodule'", "'medium'", "'-incdir'", "'module'", 
                     "'nand'", "'negedge'", "'nmos'", "'nor'", "'noshowcancelled'", 
                     "'not'", "'notif1'", "'notif0'", "'or'", "'output'", 
                     "'parameter'", "'PATHPULSE$'", "'pmos'", "'posedge'", 
                     "'primitive'", "'pulldown'", "'pull1'", "'pullup'", 
                     "'pull0'", "'pulsestyle_ondetect'", "'pulsestyle_onevent'", 
                     "'rcmos'", "'real'", "'realtime'", "'reg'", "'release'", 
                     "'repeat'", "'rnmos'", "'rpmos'", "'rtran'", "'rtranif1'", 
                     "'rtranif0'", "'scalared'", "'showcancelled'", "'signed'", 
                     "'small'", "'specify'", "'specparam'", "'strong1'", 
                     "'strong0'", "'supply1'", "'supply0'", "'table'", "'task'", 
                     "'time'", "'tran'", "'tranif1'", "'tranif0'", "'tri'", 
                     "'triand'", "'tri1'", "'trior'", "'trireg'", "'tri0'", 
                     "'use'", "'uwire'", "'vectored'", "'wait'", "'wand'", 
                     "'weak1'", "'weak0'", "'while'", "'wire'", "'wor'", 
                     "'xnor'", "'xor'", "'&'", "'&&'", "'&&&'", "'*'", "'**'", 
                     "'*>'", "'@'", "'^'", "'^~'", "':'", "','", "'$'", 
                     "'\"'", "'.'", "'!'", "'!='", "'!=='", "'='", "'=='", 
                     "'==='", "'=>'", "<INVALID>", "'>'", "'>='", "'>>'", 
                     "'>>>'", "'#'", "'['", "'{'", "'('", "'<'", "'<='", 
                     "'<<'", "'<<<'", "'-'", "'-:'", "'->'", "'%'", "'+'", 
                     "'+:'", "'?'", "']'", "'}'", "')'", "';'", "'/'", "'~'", 
                     "'~&'", "'~^'", "'~|'", "'|'", "'||'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'celldefine'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'end_keywords'", "'endcelldefine'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'nounconnected_drive'", 
                     "<INVALID>", "'resetall'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'``'", "<INVALID>", "'`\\`\"'", 
                     "'`\"'" ]

    symbolicNames = [ "<INVALID>", "ALWAYS", "AND", "ASSIGN", "AUTOMATIC", 
                      "BEGIN", "BUF", "BUFIFONE", "BUFIFZERO", "CASE", "CASEX", 
                      "CASEZ", "CELL", "CMOS", "CONFIG", "DEASSIGN", "DEFAULT", 
                      "DEFPARAM", "DESIGN", "DISABLE", "DLFULLSKEW", "DLHOLD", 
                      "DLNOCHANGE", "DLPERIOD", "DLRECOVERY", "DLRECREM", 
                      "DLREMOVAL", "DLSETUP", "DLSETUPHOLD", "DLSKEW", "DLTIMESKEW", 
                      "DLWIDTH", "EDGE", "ELSE", "END", "ENDCASE", "ENDCONFIG", 
                      "ENDFUNCTION", "ENDGENERATE", "ENDMODULE", "ENDPRIMITIVE", 
                      "ENDSPECIFY", "ENDTABLE", "ENDTASK", "EVENT", "FOR", 
                      "FORCE", "FOREVER", "FORK", "FUNCTION", "GENERATE", 
                      "GENVAR", "HIGHZONE", "HIGHZZERO", "IF", "IFNONE", 
                      "INCLUDE", "INITIAL", "INOUT", "INPUT", "INSTANCE", 
                      "INTEGER", "JOIN", "LARGE", "LIBLIST", "LIBRARY", 
                      "LOCALPARAM", "MACROMODULE", "MEDIUM", "MIINCDIR", 
                      "MODULE", "NAND", "NEGEDGE", "NMOS", "NOR", "NOSHOWCANCELLED", 
                      "NOT", "NOTIFONE", "NOTIFZERO", "OR", "OUTPUT", "PARAMETER", 
                      "PATHPULSEDL", "PMOS", "POSEDGE", "PRIMITIVE", "PULLDOWN", 
                      "PULLONE", "PULLUP", "PULLZERO", "PULSESTYLE_ONDETECT", 
                      "PULSESTYLE_ONEVENT", "RCMOS", "REAL", "REALTIME", 
                      "REG", "RELEASE", "REPEAT", "RNMOS", "RPMOS", "RTRAN", 
                      "RTRANIFONE", "RTRANIFZERO", "SCALARED", "SHOWCANCELLED", 
                      "SIGNED", "SMALL", "SPECIFY", "SPECPARAM", "STRONGONE", 
                      "STRONGZERO", "SUPPLYONE", "SUPPLYZERO", "TABLE", 
                      "TASK", "TIME", "TRAN", "TRANIFONE", "TRANIFZERO", 
                      "TRI", "TRIAND", "TRIONE", "TRIOR", "TRIREG", "TRIZERO", 
                      "USE", "UWIRE", "VECTORED", "WAIT", "WAND", "WEAKONE", 
                      "WEAKZERO", "WHILE", "WIRE", "WOR", "XNOR", "XOR", 
                      "AM", "AMAM", "AMAMAM", "AS", "ASAS", "ASGT", "AT", 
                      "CA", "CATI", "CL", "CO", "DL", "DQ", "DT", "EM", 
                      "EMEQ", "EMEQEQ", "EQ", "EQEQ", "EQEQEQ", "EQGT", 
                      "GA", "GT", "GTEQ", "GTGT", "GTGTGT", "HA", "LB", 
                      "LC", "LP", "LT", "LTEQ", "LTLT", "LTLTLT", "MI", 
                      "MICL", "MIGT", "MO", "PL", "PLCL", "QM", "RB", "RC", 
                      "RP", "SC", "SL", "TI", "TIAM", "TICA", "TIVL", "VL", 
                      "VLVL", "BINARY_BASE", "BLOCK_COMMENT", "DECIMAL_BASE", 
                      "ESCAPED_IDENTIFIER", "EXPONENTIAL_NUMBER", "FIXED_POINT_NUMBER", 
                      "HEX_BASE", "LINE_COMMENT", "OCTAL_BASE", "SIMPLE_IDENTIFIER", 
                      "STRING", "SYSTEM_TF_IDENTIFIER", "UNSIGNED_NUMBER", 
                      "WHITE_SPACE", "BINARY_VALUE", "X_OR_Z_UNDERSCORE", 
                      "EDGE_DESCRIPTOR", "HEX_VALUE", "FILE_PATH_SPEC", 
                      "OCTAL_VALUE", "EDGE_SYMBOL", "LEVEL_ONLY_SYMBOL", 
                      "OUTPUT_OR_LEVEL_SYMBOL", "BEGIN_KEYWORDS_DIRECTIVE", 
                      "CELLDEFINE_DIRECTIVE", "DEFAULT_NETTYPE_DIRECTIVE", 
                      "DEFINE_DIRECTIVE", "ELSE_DIRECTIVE", "ELSIF_DIRECTIVE", 
                      "END_KEYWORDS_DIRECTIVE", "ENDCELLDEFINE_DIRECTIVE", 
                      "ENDIF_DIRECTIVE", "IFDEF_DIRECTIVE", "IFNDEF_DIRECTIVE", 
                      "INCLUDE_DIRECTIVE", "LINE_DIRECTIVE", "NOUNCONNECTED_DRIVE_DIRECTIVE", 
                      "PRAGMA_DIRECTIVE", "RESETALL_DIRECTIVE", "TIMESCALE_DIRECTIVE", 
                      "UNCONNECTED_DRIVE_DIRECTIVE", "UNDEF_DIRECTIVE", 
                      "MACRO_USAGE", "VERSION_SPECIFIER", "DEFAULT_NETTYPE_VALUE", 
                      "MACRO_NAME", "FILENAME", "MACRO_DELIMITER", "MACRO_ESC_NEWLINE", 
                      "MACRO_ESC_QUOTE", "MACRO_QUOTE", "MACRO_TEXT", "SOURCE_TEXT", 
                      "TIME_UNIT", "TIME_VALUE", "UNCONNECTED_DRIVE_VALUE", 
                      "MACRO_IDENTIFIER" ]

    RULE_source_text = 0
    RULE_compiler_directive = 1
    RULE_begin_keywords_directive = 2
    RULE_celldefine_directive = 3
    RULE_default_nettype_directive = 4
    RULE_default_nettype_value = 5
    RULE_else_directive = 6
    RULE_elsif_directive = 7
    RULE_end_keywords_directive = 8
    RULE_endcelldefine_directive = 9
    RULE_endif_directive = 10
    RULE_filename = 11
    RULE_group_of_lines = 12
    RULE_identifier = 13
    RULE_ifdef_directive = 14
    RULE_ifndef_directive = 15
    RULE_include_directive = 16
    RULE_level = 17
    RULE_line_directive = 18
    RULE_macro_delimiter = 19
    RULE_macro_esc_newline = 20
    RULE_macro_esc_quote = 21
    RULE_macro_identifier = 22
    RULE_macro_name = 23
    RULE_macro_quote = 24
    RULE_macro_text = 25
    RULE_macro_text_ = 26
    RULE_macro_usage = 27
    RULE_nounconnected_drive_directive = 28
    RULE_number = 29
    RULE_pragma_directive = 30
    RULE_pragma_expression = 31
    RULE_pragma_keyword = 32
    RULE_pragma_name = 33
    RULE_pragma_value = 34
    RULE_resetall_directive = 35
    RULE_source_text_ = 36
    RULE_string_ = 37
    RULE_text_macro_definition = 38
    RULE_text_macro_usage = 39
    RULE_time_precision = 40
    RULE_time_unit = 41
    RULE_timescale_directive = 42
    RULE_unconnected_drive_directive = 43
    RULE_unconnected_drive_value = 44
    RULE_undef_directive = 45
    RULE_version_specifier = 46

    ruleNames =  [ "source_text", "compiler_directive", "begin_keywords_directive", 
                   "celldefine_directive", "default_nettype_directive", 
                   "default_nettype_value", "else_directive", "elsif_directive", 
                   "end_keywords_directive", "endcelldefine_directive", 
                   "endif_directive", "filename", "group_of_lines", "identifier", 
                   "ifdef_directive", "ifndef_directive", "include_directive", 
                   "level", "line_directive", "macro_delimiter", "macro_esc_newline", 
                   "macro_esc_quote", "macro_identifier", "macro_name", 
                   "macro_quote", "macro_text", "macro_text_", "macro_usage", 
                   "nounconnected_drive_directive", "number", "pragma_directive", 
                   "pragma_expression", "pragma_keyword", "pragma_name", 
                   "pragma_value", "resetall_directive", "source_text_", 
                   "string_", "text_macro_definition", "text_macro_usage", 
                   "time_precision", "time_unit", "timescale_directive", 
                   "unconnected_drive_directive", "unconnected_drive_value", 
                   "undef_directive", "version_specifier" ]

    EOF = Token.EOF
    ALWAYS=1
    AND=2
    ASSIGN=3
    AUTOMATIC=4
    BEGIN=5
    BUF=6
    BUFIFONE=7
    BUFIFZERO=8
    CASE=9
    CASEX=10
    CASEZ=11
    CELL=12
    CMOS=13
    CONFIG=14
    DEASSIGN=15
    DEFAULT=16
    DEFPARAM=17
    DESIGN=18
    DISABLE=19
    DLFULLSKEW=20
    DLHOLD=21
    DLNOCHANGE=22
    DLPERIOD=23
    DLRECOVERY=24
    DLRECREM=25
    DLREMOVAL=26
    DLSETUP=27
    DLSETUPHOLD=28
    DLSKEW=29
    DLTIMESKEW=30
    DLWIDTH=31
    EDGE=32
    ELSE=33
    END=34
    ENDCASE=35
    ENDCONFIG=36
    ENDFUNCTION=37
    ENDGENERATE=38
    ENDMODULE=39
    ENDPRIMITIVE=40
    ENDSPECIFY=41
    ENDTABLE=42
    ENDTASK=43
    EVENT=44
    FOR=45
    FORCE=46
    FOREVER=47
    FORK=48
    FUNCTION=49
    GENERATE=50
    GENVAR=51
    HIGHZONE=52
    HIGHZZERO=53
    IF=54
    IFNONE=55
    INCLUDE=56
    INITIAL=57
    INOUT=58
    INPUT=59
    INSTANCE=60
    INTEGER=61
    JOIN=62
    LARGE=63
    LIBLIST=64
    LIBRARY=65
    LOCALPARAM=66
    MACROMODULE=67
    MEDIUM=68
    MIINCDIR=69
    MODULE=70
    NAND=71
    NEGEDGE=72
    NMOS=73
    NOR=74
    NOSHOWCANCELLED=75
    NOT=76
    NOTIFONE=77
    NOTIFZERO=78
    OR=79
    OUTPUT=80
    PARAMETER=81
    PATHPULSEDL=82
    PMOS=83
    POSEDGE=84
    PRIMITIVE=85
    PULLDOWN=86
    PULLONE=87
    PULLUP=88
    PULLZERO=89
    PULSESTYLE_ONDETECT=90
    PULSESTYLE_ONEVENT=91
    RCMOS=92
    REAL=93
    REALTIME=94
    REG=95
    RELEASE=96
    REPEAT=97
    RNMOS=98
    RPMOS=99
    RTRAN=100
    RTRANIFONE=101
    RTRANIFZERO=102
    SCALARED=103
    SHOWCANCELLED=104
    SIGNED=105
    SMALL=106
    SPECIFY=107
    SPECPARAM=108
    STRONGONE=109
    STRONGZERO=110
    SUPPLYONE=111
    SUPPLYZERO=112
    TABLE=113
    TASK=114
    TIME=115
    TRAN=116
    TRANIFONE=117
    TRANIFZERO=118
    TRI=119
    TRIAND=120
    TRIONE=121
    TRIOR=122
    TRIREG=123
    TRIZERO=124
    USE=125
    UWIRE=126
    VECTORED=127
    WAIT=128
    WAND=129
    WEAKONE=130
    WEAKZERO=131
    WHILE=132
    WIRE=133
    WOR=134
    XNOR=135
    XOR=136
    AM=137
    AMAM=138
    AMAMAM=139
    AS=140
    ASAS=141
    ASGT=142
    AT=143
    CA=144
    CATI=145
    CL=146
    CO=147
    DL=148
    DQ=149
    DT=150
    EM=151
    EMEQ=152
    EMEQEQ=153
    EQ=154
    EQEQ=155
    EQEQEQ=156
    EQGT=157
    GA=158
    GT=159
    GTEQ=160
    GTGT=161
    GTGTGT=162
    HA=163
    LB=164
    LC=165
    LP=166
    LT=167
    LTEQ=168
    LTLT=169
    LTLTLT=170
    MI=171
    MICL=172
    MIGT=173
    MO=174
    PL=175
    PLCL=176
    QM=177
    RB=178
    RC=179
    RP=180
    SC=181
    SL=182
    TI=183
    TIAM=184
    TICA=185
    TIVL=186
    VL=187
    VLVL=188
    BINARY_BASE=189
    BLOCK_COMMENT=190
    DECIMAL_BASE=191
    ESCAPED_IDENTIFIER=192
    EXPONENTIAL_NUMBER=193
    FIXED_POINT_NUMBER=194
    HEX_BASE=195
    LINE_COMMENT=196
    OCTAL_BASE=197
    SIMPLE_IDENTIFIER=198
    STRING=199
    SYSTEM_TF_IDENTIFIER=200
    UNSIGNED_NUMBER=201
    WHITE_SPACE=202
    BINARY_VALUE=203
    X_OR_Z_UNDERSCORE=204
    EDGE_DESCRIPTOR=205
    HEX_VALUE=206
    FILE_PATH_SPEC=207
    OCTAL_VALUE=208
    EDGE_SYMBOL=209
    LEVEL_ONLY_SYMBOL=210
    OUTPUT_OR_LEVEL_SYMBOL=211
    BEGIN_KEYWORDS_DIRECTIVE=212
    CELLDEFINE_DIRECTIVE=213
    DEFAULT_NETTYPE_DIRECTIVE=214
    DEFINE_DIRECTIVE=215
    ELSE_DIRECTIVE=216
    ELSIF_DIRECTIVE=217
    END_KEYWORDS_DIRECTIVE=218
    ENDCELLDEFINE_DIRECTIVE=219
    ENDIF_DIRECTIVE=220
    IFDEF_DIRECTIVE=221
    IFNDEF_DIRECTIVE=222
    INCLUDE_DIRECTIVE=223
    LINE_DIRECTIVE=224
    NOUNCONNECTED_DRIVE_DIRECTIVE=225
    PRAGMA_DIRECTIVE=226
    RESETALL_DIRECTIVE=227
    TIMESCALE_DIRECTIVE=228
    UNCONNECTED_DRIVE_DIRECTIVE=229
    UNDEF_DIRECTIVE=230
    MACRO_USAGE=231
    VERSION_SPECIFIER=232
    DEFAULT_NETTYPE_VALUE=233
    MACRO_NAME=234
    FILENAME=235
    MACRO_DELIMITER=236
    MACRO_ESC_NEWLINE=237
    MACRO_ESC_QUOTE=238
    MACRO_QUOTE=239
    MACRO_TEXT=240
    SOURCE_TEXT=241
    TIME_UNIT=242
    TIME_VALUE=243
    UNCONNECTED_DRIVE_VALUE=244
    MACRO_IDENTIFIER=245

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Source_textContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compiler_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Compiler_directiveContext)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Compiler_directiveContext,i)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_source_text

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSource_text" ):
                return visitor.visitSource_text(self)
            else:
                return visitor.visitChildren(self)




    def source_text(self):

        localctx = VerilogPreParser.Source_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_source_text)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==158:
                self.state = 94
                self.compiler_directive()
                self.state = 99
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Compiler_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def begin_keywords_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Begin_keywords_directiveContext,0)


        def celldefine_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Celldefine_directiveContext,0)


        def default_nettype_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Default_nettype_directiveContext,0)


        def end_keywords_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.End_keywords_directiveContext,0)


        def endcelldefine_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Endcelldefine_directiveContext,0)


        def ifdef_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Ifdef_directiveContext,0)


        def ifndef_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Ifndef_directiveContext,0)


        def include_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Include_directiveContext,0)


        def line_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Line_directiveContext,0)


        def nounconnected_drive_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Nounconnected_drive_directiveContext,0)


        def pragma_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Pragma_directiveContext,0)


        def resetall_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Resetall_directiveContext,0)


        def text_macro_definition(self):
            return self.getTypedRuleContext(VerilogPreParser.Text_macro_definitionContext,0)


        def text_macro_usage(self):
            return self.getTypedRuleContext(VerilogPreParser.Text_macro_usageContext,0)


        def timescale_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Timescale_directiveContext,0)


        def unconnected_drive_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Unconnected_drive_directiveContext,0)


        def undef_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Undef_directiveContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_compiler_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompiler_directive" ):
                return visitor.visitCompiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def compiler_directive(self):

        localctx = VerilogPreParser.Compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_compiler_directive)
        try:
            self.state = 117
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 100
                self.begin_keywords_directive()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 101
                self.celldefine_directive()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 102
                self.default_nettype_directive()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 103
                self.end_keywords_directive()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 104
                self.endcelldefine_directive()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 105
                self.ifdef_directive()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 106
                self.ifndef_directive()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 107
                self.include_directive()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 108
                self.line_directive()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 109
                self.nounconnected_drive_directive()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 110
                self.pragma_directive()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 111
                self.resetall_directive()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 112
                self.text_macro_definition()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 113
                self.text_macro_usage()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 114
                self.timescale_directive()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 115
                self.unconnected_drive_directive()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 116
                self.undef_directive()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Begin_keywords_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def BEGIN_KEYWORDS_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.BEGIN_KEYWORDS_DIRECTIVE, 0)

        def DQ(self, i:int=None):
            if i is None:
                return self.getTokens(VerilogPreParser.DQ)
            else:
                return self.getToken(VerilogPreParser.DQ, i)

        def version_specifier(self):
            return self.getTypedRuleContext(VerilogPreParser.Version_specifierContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_begin_keywords_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegin_keywords_directive" ):
                return visitor.visitBegin_keywords_directive(self)
            else:
                return visitor.visitChildren(self)




    def begin_keywords_directive(self):

        localctx = VerilogPreParser.Begin_keywords_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_begin_keywords_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.match(VerilogPreParser.GA)
            self.state = 120
            self.match(VerilogPreParser.BEGIN_KEYWORDS_DIRECTIVE)
            self.state = 121
            self.match(VerilogPreParser.DQ)
            self.state = 122
            self.version_specifier()
            self.state = 123
            self.match(VerilogPreParser.DQ)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Celldefine_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def CELLDEFINE_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.CELLDEFINE_DIRECTIVE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_celldefine_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCelldefine_directive" ):
                return visitor.visitCelldefine_directive(self)
            else:
                return visitor.visitChildren(self)




    def celldefine_directive(self):

        localctx = VerilogPreParser.Celldefine_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_celldefine_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.match(VerilogPreParser.GA)
            self.state = 126
            self.match(VerilogPreParser.CELLDEFINE_DIRECTIVE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Default_nettype_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def DEFAULT_NETTYPE_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.DEFAULT_NETTYPE_DIRECTIVE, 0)

        def default_nettype_value(self):
            return self.getTypedRuleContext(VerilogPreParser.Default_nettype_valueContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_default_nettype_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault_nettype_directive" ):
                return visitor.visitDefault_nettype_directive(self)
            else:
                return visitor.visitChildren(self)




    def default_nettype_directive(self):

        localctx = VerilogPreParser.Default_nettype_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_default_nettype_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self.match(VerilogPreParser.GA)
            self.state = 129
            self.match(VerilogPreParser.DEFAULT_NETTYPE_DIRECTIVE)
            self.state = 130
            self.default_nettype_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Default_nettype_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT_NETTYPE_VALUE(self):
            return self.getToken(VerilogPreParser.DEFAULT_NETTYPE_VALUE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_default_nettype_value

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault_nettype_value" ):
                return visitor.visitDefault_nettype_value(self)
            else:
                return visitor.visitChildren(self)




    def default_nettype_value(self):

        localctx = VerilogPreParser.Default_nettype_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_default_nettype_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(VerilogPreParser.DEFAULT_NETTYPE_VALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Else_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def ELSE_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.ELSE_DIRECTIVE, 0)

        def group_of_lines(self):
            return self.getTypedRuleContext(VerilogPreParser.Group_of_linesContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_else_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElse_directive" ):
                return visitor.visitElse_directive(self)
            else:
                return visitor.visitChildren(self)




    def else_directive(self):

        localctx = VerilogPreParser.Else_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_else_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self.match(VerilogPreParser.GA)
            self.state = 135
            self.match(VerilogPreParser.ELSE_DIRECTIVE)
            self.state = 136
            self.group_of_lines()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Elsif_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def ELSIF_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.ELSIF_DIRECTIVE, 0)

        def macro_identifier(self):
            return self.getTypedRuleContext(VerilogPreParser.Macro_identifierContext,0)


        def group_of_lines(self):
            return self.getTypedRuleContext(VerilogPreParser.Group_of_linesContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_elsif_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElsif_directive" ):
                return visitor.visitElsif_directive(self)
            else:
                return visitor.visitChildren(self)




    def elsif_directive(self):

        localctx = VerilogPreParser.Elsif_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_elsif_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138
            self.match(VerilogPreParser.GA)
            self.state = 139
            self.match(VerilogPreParser.ELSIF_DIRECTIVE)
            self.state = 140
            self.macro_identifier()
            self.state = 141
            self.group_of_lines()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class End_keywords_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def END_KEYWORDS_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.END_KEYWORDS_DIRECTIVE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_end_keywords_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnd_keywords_directive" ):
                return visitor.visitEnd_keywords_directive(self)
            else:
                return visitor.visitChildren(self)




    def end_keywords_directive(self):

        localctx = VerilogPreParser.End_keywords_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_end_keywords_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.match(VerilogPreParser.GA)
            self.state = 144
            self.match(VerilogPreParser.END_KEYWORDS_DIRECTIVE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Endcelldefine_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def ENDCELLDEFINE_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.ENDCELLDEFINE_DIRECTIVE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_endcelldefine_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndcelldefine_directive" ):
                return visitor.visitEndcelldefine_directive(self)
            else:
                return visitor.visitChildren(self)




    def endcelldefine_directive(self):

        localctx = VerilogPreParser.Endcelldefine_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_endcelldefine_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            self.match(VerilogPreParser.GA)
            self.state = 147
            self.match(VerilogPreParser.ENDCELLDEFINE_DIRECTIVE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Endif_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def ENDIF_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.ENDIF_DIRECTIVE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_endif_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndif_directive" ):
                return visitor.visitEndif_directive(self)
            else:
                return visitor.visitChildren(self)




    def endif_directive(self):

        localctx = VerilogPreParser.Endif_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_endif_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            self.match(VerilogPreParser.GA)
            self.state = 150
            self.match(VerilogPreParser.ENDIF_DIRECTIVE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILENAME(self):
            return self.getToken(VerilogPreParser.FILENAME, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_filename

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilename" ):
                return visitor.visitFilename(self)
            else:
                return visitor.visitChildren(self)




    def filename(self):

        localctx = VerilogPreParser.FilenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_filename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            self.match(VerilogPreParser.FILENAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_of_linesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def source_text_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Source_text_Context)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Source_text_Context,i)


        def compiler_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Compiler_directiveContext)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Compiler_directiveContext,i)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_group_of_lines

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroup_of_lines" ):
                return visitor.visitGroup_of_lines(self)
            else:
                return visitor.visitChildren(self)




    def group_of_lines(self):

        localctx = VerilogPreParser.Group_of_linesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_group_of_lines)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 156
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [241]:
                        self.state = 154
                        self.source_text_()
                        pass
                    elif token in [158]:
                        self.state = 155
                        self.compiler_directive()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 160
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIMPLE_IDENTIFIER(self):
            return self.getToken(VerilogPreParser.SIMPLE_IDENTIFIER, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_identifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = VerilogPreParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self.match(VerilogPreParser.SIMPLE_IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ifdef_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def IFDEF_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.IFDEF_DIRECTIVE, 0)

        def macro_identifier(self):
            return self.getTypedRuleContext(VerilogPreParser.Macro_identifierContext,0)


        def group_of_lines(self):
            return self.getTypedRuleContext(VerilogPreParser.Group_of_linesContext,0)


        def endif_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Endif_directiveContext,0)


        def elsif_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Elsif_directiveContext)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Elsif_directiveContext,i)


        def else_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Else_directiveContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_ifdef_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfdef_directive" ):
                return visitor.visitIfdef_directive(self)
            else:
                return visitor.visitChildren(self)




    def ifdef_directive(self):

        localctx = VerilogPreParser.Ifdef_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_ifdef_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.match(VerilogPreParser.GA)
            self.state = 164
            self.match(VerilogPreParser.IFDEF_DIRECTIVE)
            self.state = 165
            self.macro_identifier()
            self.state = 166
            self.group_of_lines()
            self.state = 170
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 167
                    self.elsif_directive() 
                self.state = 172
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

            self.state = 174
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 173
                self.else_directive()


            self.state = 176
            self.endif_directive()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ifndef_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def IFNDEF_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.IFNDEF_DIRECTIVE, 0)

        def macro_identifier(self):
            return self.getTypedRuleContext(VerilogPreParser.Macro_identifierContext,0)


        def group_of_lines(self):
            return self.getTypedRuleContext(VerilogPreParser.Group_of_linesContext,0)


        def endif_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Endif_directiveContext,0)


        def elsif_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Elsif_directiveContext)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Elsif_directiveContext,i)


        def else_directive(self):
            return self.getTypedRuleContext(VerilogPreParser.Else_directiveContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_ifndef_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfndef_directive" ):
                return visitor.visitIfndef_directive(self)
            else:
                return visitor.visitChildren(self)




    def ifndef_directive(self):

        localctx = VerilogPreParser.Ifndef_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_ifndef_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            self.match(VerilogPreParser.GA)
            self.state = 179
            self.match(VerilogPreParser.IFNDEF_DIRECTIVE)
            self.state = 180
            self.macro_identifier()
            self.state = 181
            self.group_of_lines()
            self.state = 185
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 182
                    self.elsif_directive() 
                self.state = 187
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 189
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 188
                self.else_directive()


            self.state = 191
            self.endif_directive()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Include_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def INCLUDE_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.INCLUDE_DIRECTIVE, 0)

        def DQ(self, i:int=None):
            if i is None:
                return self.getTokens(VerilogPreParser.DQ)
            else:
                return self.getToken(VerilogPreParser.DQ, i)

        def filename(self):
            return self.getTypedRuleContext(VerilogPreParser.FilenameContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_include_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInclude_directive" ):
                return visitor.visitInclude_directive(self)
            else:
                return visitor.visitChildren(self)




    def include_directive(self):

        localctx = VerilogPreParser.Include_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_include_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(VerilogPreParser.GA)
            self.state = 194
            self.match(VerilogPreParser.INCLUDE_DIRECTIVE)
            self.state = 195
            self.match(VerilogPreParser.DQ)
            self.state = 196
            self.filename()
            self.state = 197
            self.match(VerilogPreParser.DQ)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNSIGNED_NUMBER(self):
            return self.getToken(VerilogPreParser.UNSIGNED_NUMBER, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_level

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLevel" ):
                return visitor.visitLevel(self)
            else:
                return visitor.visitChildren(self)




    def level(self):

        localctx = VerilogPreParser.LevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_level)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.match(VerilogPreParser.UNSIGNED_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Line_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def LINE_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.LINE_DIRECTIVE, 0)

        def number(self):
            return self.getTypedRuleContext(VerilogPreParser.NumberContext,0)


        def DQ(self, i:int=None):
            if i is None:
                return self.getTokens(VerilogPreParser.DQ)
            else:
                return self.getToken(VerilogPreParser.DQ, i)

        def filename(self):
            return self.getTypedRuleContext(VerilogPreParser.FilenameContext,0)


        def level(self):
            return self.getTypedRuleContext(VerilogPreParser.LevelContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_line_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLine_directive" ):
                return visitor.visitLine_directive(self)
            else:
                return visitor.visitChildren(self)




    def line_directive(self):

        localctx = VerilogPreParser.Line_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_line_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(VerilogPreParser.GA)
            self.state = 202
            self.match(VerilogPreParser.LINE_DIRECTIVE)
            self.state = 203
            self.number()
            self.state = 204
            self.match(VerilogPreParser.DQ)
            self.state = 205
            self.filename()
            self.state = 206
            self.match(VerilogPreParser.DQ)
            self.state = 207
            self.level()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_delimiterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MACRO_DELIMITER(self):
            return self.getToken(VerilogPreParser.MACRO_DELIMITER, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_macro_delimiter

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacro_delimiter" ):
                return visitor.visitMacro_delimiter(self)
            else:
                return visitor.visitChildren(self)




    def macro_delimiter(self):

        localctx = VerilogPreParser.Macro_delimiterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_macro_delimiter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.match(VerilogPreParser.MACRO_DELIMITER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_esc_newlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MACRO_ESC_NEWLINE(self):
            return self.getToken(VerilogPreParser.MACRO_ESC_NEWLINE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_macro_esc_newline

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacro_esc_newline" ):
                return visitor.visitMacro_esc_newline(self)
            else:
                return visitor.visitChildren(self)




    def macro_esc_newline(self):

        localctx = VerilogPreParser.Macro_esc_newlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_macro_esc_newline)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(VerilogPreParser.MACRO_ESC_NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_esc_quoteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MACRO_ESC_QUOTE(self):
            return self.getToken(VerilogPreParser.MACRO_ESC_QUOTE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_macro_esc_quote

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacro_esc_quote" ):
                return visitor.visitMacro_esc_quote(self)
            else:
                return visitor.visitChildren(self)




    def macro_esc_quote(self):

        localctx = VerilogPreParser.Macro_esc_quoteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_macro_esc_quote)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(VerilogPreParser.MACRO_ESC_QUOTE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_identifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MACRO_IDENTIFIER(self):
            return self.getToken(VerilogPreParser.MACRO_IDENTIFIER, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_macro_identifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacro_identifier" ):
                return visitor.visitMacro_identifier(self)
            else:
                return visitor.visitChildren(self)




    def macro_identifier(self):

        localctx = VerilogPreParser.Macro_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_macro_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 215
            self.match(VerilogPreParser.MACRO_IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MACRO_NAME(self):
            return self.getToken(VerilogPreParser.MACRO_NAME, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_macro_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacro_name" ):
                return visitor.visitMacro_name(self)
            else:
                return visitor.visitChildren(self)




    def macro_name(self):

        localctx = VerilogPreParser.Macro_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_macro_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 217
            self.match(VerilogPreParser.MACRO_NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_quoteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MACRO_QUOTE(self):
            return self.getToken(VerilogPreParser.MACRO_QUOTE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_macro_quote

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacro_quote" ):
                return visitor.visitMacro_quote(self)
            else:
                return visitor.visitChildren(self)




    def macro_quote(self):

        localctx = VerilogPreParser.Macro_quoteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_macro_quote)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            self.match(VerilogPreParser.MACRO_QUOTE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_textContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def macro_text_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Macro_text_Context)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Macro_text_Context,i)


        def macro_delimiter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Macro_delimiterContext)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Macro_delimiterContext,i)


        def macro_esc_newline(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Macro_esc_newlineContext)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Macro_esc_newlineContext,i)


        def macro_esc_quote(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Macro_esc_quoteContext)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Macro_esc_quoteContext,i)


        def macro_quote(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Macro_quoteContext)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Macro_quoteContext,i)


        def string_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.String_Context)
            else:
                return self.getTypedRuleContext(VerilogPreParser.String_Context,i)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_macro_text

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacro_text" ):
                return visitor.visitMacro_text(self)
            else:
                return visitor.visitChildren(self)




    def macro_text(self):

        localctx = VerilogPreParser.Macro_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_macro_text)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 229
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 199)) & ~0x3f) == 0 and ((1 << (_la - 199)) & 4260607557633) != 0):
                self.state = 227
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [240]:
                    self.state = 221
                    self.macro_text_()
                    pass
                elif token in [236]:
                    self.state = 222
                    self.macro_delimiter()
                    pass
                elif token in [237]:
                    self.state = 223
                    self.macro_esc_newline()
                    pass
                elif token in [238]:
                    self.state = 224
                    self.macro_esc_quote()
                    pass
                elif token in [239]:
                    self.state = 225
                    self.macro_quote()
                    pass
                elif token in [199]:
                    self.state = 226
                    self.string_()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 231
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_text_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MACRO_TEXT(self):
            return self.getToken(VerilogPreParser.MACRO_TEXT, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_macro_text_

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacro_text_" ):
                return visitor.visitMacro_text_(self)
            else:
                return visitor.visitChildren(self)




    def macro_text_(self):

        localctx = VerilogPreParser.Macro_text_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_macro_text_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self.match(VerilogPreParser.MACRO_TEXT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_usageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MACRO_USAGE(self):
            return self.getToken(VerilogPreParser.MACRO_USAGE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_macro_usage

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacro_usage" ):
                return visitor.visitMacro_usage(self)
            else:
                return visitor.visitChildren(self)




    def macro_usage(self):

        localctx = VerilogPreParser.Macro_usageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_macro_usage)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            self.match(VerilogPreParser.MACRO_USAGE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Nounconnected_drive_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def NOUNCONNECTED_DRIVE_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.NOUNCONNECTED_DRIVE_DIRECTIVE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_nounconnected_drive_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNounconnected_drive_directive" ):
                return visitor.visitNounconnected_drive_directive(self)
            else:
                return visitor.visitChildren(self)




    def nounconnected_drive_directive(self):

        localctx = VerilogPreParser.Nounconnected_drive_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_nounconnected_drive_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self.match(VerilogPreParser.GA)
            self.state = 237
            self.match(VerilogPreParser.NOUNCONNECTED_DRIVE_DIRECTIVE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNSIGNED_NUMBER(self):
            return self.getToken(VerilogPreParser.UNSIGNED_NUMBER, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_number

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = VerilogPreParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            self.match(VerilogPreParser.UNSIGNED_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pragma_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def PRAGMA_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.PRAGMA_DIRECTIVE, 0)

        def pragma_name(self):
            return self.getTypedRuleContext(VerilogPreParser.Pragma_nameContext,0)


        def pragma_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Pragma_expressionContext)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Pragma_expressionContext,i)


        def CO(self, i:int=None):
            if i is None:
                return self.getTokens(VerilogPreParser.CO)
            else:
                return self.getToken(VerilogPreParser.CO, i)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_pragma_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPragma_directive" ):
                return visitor.visitPragma_directive(self)
            else:
                return visitor.visitChildren(self)




    def pragma_directive(self):

        localctx = VerilogPreParser.Pragma_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_pragma_directive)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            self.match(VerilogPreParser.GA)
            self.state = 242
            self.match(VerilogPreParser.PRAGMA_DIRECTIVE)
            self.state = 243
            self.pragma_name()
            self.state = 252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 166)) & ~0x3f) == 0 and ((1 << (_la - 166)) & 47244640257) != 0):
                self.state = 244
                self.pragma_expression()
                self.state = 249
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==147:
                    self.state = 245
                    self.match(VerilogPreParser.CO)
                    self.state = 246
                    self.pragma_expression()
                    self.state = 251
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pragma_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pragma_value(self):
            return self.getTypedRuleContext(VerilogPreParser.Pragma_valueContext,0)


        def pragma_keyword(self):
            return self.getTypedRuleContext(VerilogPreParser.Pragma_keywordContext,0)


        def EQ(self):
            return self.getToken(VerilogPreParser.EQ, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_pragma_expression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPragma_expression" ):
                return visitor.visitPragma_expression(self)
            else:
                return visitor.visitChildren(self)




    def pragma_expression(self):

        localctx = VerilogPreParser.Pragma_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_pragma_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 257
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.state = 254
                self.pragma_keyword()
                self.state = 255
                self.match(VerilogPreParser.EQ)


            self.state = 259
            self.pragma_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pragma_keywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIMPLE_IDENTIFIER(self):
            return self.getToken(VerilogPreParser.SIMPLE_IDENTIFIER, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_pragma_keyword

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPragma_keyword" ):
                return visitor.visitPragma_keyword(self)
            else:
                return visitor.visitChildren(self)




    def pragma_keyword(self):

        localctx = VerilogPreParser.Pragma_keywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_pragma_keyword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 261
            self.match(VerilogPreParser.SIMPLE_IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pragma_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIMPLE_IDENTIFIER(self):
            return self.getToken(VerilogPreParser.SIMPLE_IDENTIFIER, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_pragma_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPragma_name" ):
                return visitor.visitPragma_name(self)
            else:
                return visitor.visitChildren(self)




    def pragma_name(self):

        localctx = VerilogPreParser.Pragma_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_pragma_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 263
            self.match(VerilogPreParser.SIMPLE_IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pragma_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LP(self):
            return self.getToken(VerilogPreParser.LP, 0)

        def pragma_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreParser.Pragma_expressionContext)
            else:
                return self.getTypedRuleContext(VerilogPreParser.Pragma_expressionContext,i)


        def RP(self):
            return self.getToken(VerilogPreParser.RP, 0)

        def CO(self, i:int=None):
            if i is None:
                return self.getTokens(VerilogPreParser.CO)
            else:
                return self.getToken(VerilogPreParser.CO, i)

        def number(self):
            return self.getTypedRuleContext(VerilogPreParser.NumberContext,0)


        def string_(self):
            return self.getTypedRuleContext(VerilogPreParser.String_Context,0)


        def identifier(self):
            return self.getTypedRuleContext(VerilogPreParser.IdentifierContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_pragma_value

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPragma_value" ):
                return visitor.visitPragma_value(self)
            else:
                return visitor.visitChildren(self)




    def pragma_value(self):

        localctx = VerilogPreParser.Pragma_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_pragma_value)
        self._la = 0 # Token type
        try:
            self.state = 279
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [166]:
                self.enterOuterAlt(localctx, 1)
                self.state = 265
                self.match(VerilogPreParser.LP)
                self.state = 266
                self.pragma_expression()
                self.state = 271
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==147:
                    self.state = 267
                    self.match(VerilogPreParser.CO)
                    self.state = 268
                    self.pragma_expression()
                    self.state = 273
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 274
                self.match(VerilogPreParser.RP)
                pass
            elif token in [201]:
                self.enterOuterAlt(localctx, 2)
                self.state = 276
                self.number()
                pass
            elif token in [199]:
                self.enterOuterAlt(localctx, 3)
                self.state = 277
                self.string_()
                pass
            elif token in [198]:
                self.enterOuterAlt(localctx, 4)
                self.state = 278
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Resetall_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def RESETALL_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.RESETALL_DIRECTIVE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_resetall_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResetall_directive" ):
                return visitor.visitResetall_directive(self)
            else:
                return visitor.visitChildren(self)




    def resetall_directive(self):

        localctx = VerilogPreParser.Resetall_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_resetall_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 281
            self.match(VerilogPreParser.GA)
            self.state = 282
            self.match(VerilogPreParser.RESETALL_DIRECTIVE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Source_text_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SOURCE_TEXT(self):
            return self.getToken(VerilogPreParser.SOURCE_TEXT, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_source_text_

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSource_text_" ):
                return visitor.visitSource_text_(self)
            else:
                return visitor.visitChildren(self)




    def source_text_(self):

        localctx = VerilogPreParser.Source_text_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_source_text_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 284
            self.match(VerilogPreParser.SOURCE_TEXT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class String_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(VerilogPreParser.STRING, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_string_

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitString_" ):
                return visitor.visitString_(self)
            else:
                return visitor.visitChildren(self)




    def string_(self):

        localctx = VerilogPreParser.String_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_string_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self.match(VerilogPreParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Text_macro_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def DEFINE_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.DEFINE_DIRECTIVE, 0)

        def macro_name(self):
            return self.getTypedRuleContext(VerilogPreParser.Macro_nameContext,0)


        def macro_text(self):
            return self.getTypedRuleContext(VerilogPreParser.Macro_textContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_text_macro_definition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitText_macro_definition" ):
                return visitor.visitText_macro_definition(self)
            else:
                return visitor.visitChildren(self)




    def text_macro_definition(self):

        localctx = VerilogPreParser.Text_macro_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_text_macro_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self.match(VerilogPreParser.GA)
            self.state = 289
            self.match(VerilogPreParser.DEFINE_DIRECTIVE)
            self.state = 290
            self.macro_name()
            self.state = 291
            self.macro_text()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Text_macro_usageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def macro_usage(self):
            return self.getTypedRuleContext(VerilogPreParser.Macro_usageContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_text_macro_usage

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitText_macro_usage" ):
                return visitor.visitText_macro_usage(self)
            else:
                return visitor.visitChildren(self)




    def text_macro_usage(self):

        localctx = VerilogPreParser.Text_macro_usageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_text_macro_usage)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 293
            self.match(VerilogPreParser.GA)
            self.state = 294
            self.macro_usage()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_precisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIME_VALUE(self):
            return self.getToken(VerilogPreParser.TIME_VALUE, 0)

        def TIME_UNIT(self):
            return self.getToken(VerilogPreParser.TIME_UNIT, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_time_precision

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_precision" ):
                return visitor.visitTime_precision(self)
            else:
                return visitor.visitChildren(self)




    def time_precision(self):

        localctx = VerilogPreParser.Time_precisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_time_precision)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.match(VerilogPreParser.TIME_VALUE)
            self.state = 297
            self.match(VerilogPreParser.TIME_UNIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_unitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIME_VALUE(self):
            return self.getToken(VerilogPreParser.TIME_VALUE, 0)

        def TIME_UNIT(self):
            return self.getToken(VerilogPreParser.TIME_UNIT, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_time_unit

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_unit" ):
                return visitor.visitTime_unit(self)
            else:
                return visitor.visitChildren(self)




    def time_unit(self):

        localctx = VerilogPreParser.Time_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_time_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 299
            self.match(VerilogPreParser.TIME_VALUE)
            self.state = 300
            self.match(VerilogPreParser.TIME_UNIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Timescale_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def TIMESCALE_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.TIMESCALE_DIRECTIVE, 0)

        def time_unit(self):
            return self.getTypedRuleContext(VerilogPreParser.Time_unitContext,0)


        def SL(self):
            return self.getToken(VerilogPreParser.SL, 0)

        def time_precision(self):
            return self.getTypedRuleContext(VerilogPreParser.Time_precisionContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_timescale_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimescale_directive" ):
                return visitor.visitTimescale_directive(self)
            else:
                return visitor.visitChildren(self)




    def timescale_directive(self):

        localctx = VerilogPreParser.Timescale_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_timescale_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self.match(VerilogPreParser.GA)
            self.state = 303
            self.match(VerilogPreParser.TIMESCALE_DIRECTIVE)
            self.state = 304
            self.time_unit()
            self.state = 305
            self.match(VerilogPreParser.SL)
            self.state = 306
            self.time_precision()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unconnected_drive_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def UNCONNECTED_DRIVE_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.UNCONNECTED_DRIVE_DIRECTIVE, 0)

        def unconnected_drive_value(self):
            return self.getTypedRuleContext(VerilogPreParser.Unconnected_drive_valueContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_unconnected_drive_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnconnected_drive_directive" ):
                return visitor.visitUnconnected_drive_directive(self)
            else:
                return visitor.visitChildren(self)




    def unconnected_drive_directive(self):

        localctx = VerilogPreParser.Unconnected_drive_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_unconnected_drive_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 308
            self.match(VerilogPreParser.GA)
            self.state = 309
            self.match(VerilogPreParser.UNCONNECTED_DRIVE_DIRECTIVE)
            self.state = 310
            self.unconnected_drive_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unconnected_drive_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNCONNECTED_DRIVE_VALUE(self):
            return self.getToken(VerilogPreParser.UNCONNECTED_DRIVE_VALUE, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_unconnected_drive_value

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnconnected_drive_value" ):
                return visitor.visitUnconnected_drive_value(self)
            else:
                return visitor.visitChildren(self)




    def unconnected_drive_value(self):

        localctx = VerilogPreParser.Unconnected_drive_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_unconnected_drive_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 312
            self.match(VerilogPreParser.UNCONNECTED_DRIVE_VALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Undef_directiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GA(self):
            return self.getToken(VerilogPreParser.GA, 0)

        def UNDEF_DIRECTIVE(self):
            return self.getToken(VerilogPreParser.UNDEF_DIRECTIVE, 0)

        def macro_identifier(self):
            return self.getTypedRuleContext(VerilogPreParser.Macro_identifierContext,0)


        def getRuleIndex(self):
            return VerilogPreParser.RULE_undef_directive

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndef_directive" ):
                return visitor.visitUndef_directive(self)
            else:
                return visitor.visitChildren(self)




    def undef_directive(self):

        localctx = VerilogPreParser.Undef_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_undef_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 314
            self.match(VerilogPreParser.GA)
            self.state = 315
            self.match(VerilogPreParser.UNDEF_DIRECTIVE)
            self.state = 316
            self.macro_identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Version_specifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VERSION_SPECIFIER(self):
            return self.getToken(VerilogPreParser.VERSION_SPECIFIER, 0)

        def getRuleIndex(self):
            return VerilogPreParser.RULE_version_specifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersion_specifier" ):
                return visitor.visitVersion_specifier(self)
            else:
                return visitor.visitChildren(self)




    def version_specifier(self):

        localctx = VerilogPreParser.Version_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_version_specifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            self.match(VerilogPreParser.VERSION_SPECIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





